In the timed chalenge, I used a stack that consisted of Python list. It was to check whether brackets were balanced, and thus it is logical that LIFO structure should be used here, u push each opening symbol and when u meet a closing one, it has to match the last opener. List provides u with O(1) add/take away on the end and makes things short and readable, and that is what u would prefer when u re in a rush with time. I also made no consideration of any unbracketed characters in order to allow the function to receive mixed input, such as a text containing brackets which were put within.

The 30-minute time constraint compelled me to use an already tested general algorithm rather than looking out at alternatives. I not only made sure that it works not only on common cases but also on the edge cases (empty input, individual symbols, control of their orders) but created a small loop instead of creating helper classes or additional abstractions. Time pressure also meant that I added a small test harness in the file such that I could easily check behavior without establishing a test suite.

The reason I selected Python as a dynamic typed language is that initially I was just using a basic type guard. That made the code simple to write, though I had to modify it after I wrote it making me know that iterables were not necessarily strings. I also selected a number of tests that were of interest to me rather than just doing all the combinations which would have been more time consuming. Essentially this method is about deliver the code correct, on time and is willing to tradeoff a little in flexibility and formal testing.